import pefile
import capstone
import psutil
import yara
import frida
import hashlib
import os
import time

# ANSI color codes for TUI
RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"

# Utility functions
def calculate_hash(file_path):
    """Calculate and return the SHA256 hash of the file."""
    try:
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception as e:
        print(RED + f"Error calculating hash: {str(e)}" + RESET)
        sys.exit(1)

# PE Header Analysis
def analyze_pe(file_path):
    """Analyze the PE headers for suspicious entries."""
    try:
        pe = pefile.PE(file_path)
        print(CYAN + "Analyzing PE Header..." + RESET)
        print(f"Entry Point: {CYAN}{hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}{RESET}")
        print(f"Number of Sections: {CYAN}{pe.FILE_HEADER.NumberOfSections}{RESET}")
        
        # Check imported functions
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            print(YELLOW + "Imports:" + RESET)
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                print(f"  DLL: {CYAN}{entry.dll.decode('utf-8')}{RESET}")
                for func in entry.imports:
                    print(f"    {CYAN}{func.name.decode('utf-8')}{RESET}")
    except Exception as e:
        print(RED + f"Error analyzing PE file: {str(e)}" + RESET)

# Disassemble the binary
def disassemble_binary(file_path):
    """Disassemble the binary code and analyze instructions."""
    try:
        with open(file_path, "rb") as binary:
            code = binary.read()
            md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            print(CYAN + "Disassembling binary..." + RESET)
            for i in md.disasm(code, 0x1000):
                print(f"0x{i.address:x}:\t{CYAN}{i.mnemonic}\t{i.op_str}{RESET}")
    except Exception as e:
        print(RED + f"Error disassembling binary: {str(e)}" + RESET)

# YARA Rule Matching
def apply_yara_rules(file_path, yara_rule_file):
    """Apply YARA rules to the file."""
    if yara_rule_file:
        try:
            rules = yara.compile(filepath=yara_rule_file)
            matches = rules.match(file_path)
            if matches:
                print(f"YARA match found: {CYAN}{matches}{RESET}")
            else:
                print(YELLOW + "No YARA rule match found." + RESET)
        except Exception as e:
            print(RED + f"Error applying YARA rules: {str(e)}" + RESET)

# Memory Analysis (using psutil)
def analyze_process_memory(process_name):
    """Analyze the memory usage of a specific process."""
    if process_name:
        try:
            print(f"Analyzing memory usage of {CYAN}{process_name}{RESET}...")
            found = False
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                if proc.info['name'] == process_name:
                    print(f"PID: {CYAN}{proc.info['pid']}{RESET}, Memory Usage: {CYAN}{proc.info['memory_info'].rss / (1024 * 1024):.2f} MB{RESET}")
                    found = True
            if not found:
                print(RED + f"No process found with name {process_name}" + RESET)
        except Exception as e:
            print(RED + f"Error analyzing process memory: {str(e)}" + RESET)

# Dynamic Analysis (Frida)
def dynamic_analysis(script_code, target_process):
    """Use Frida to dynamically inject and monitor behavior."""
    if target_process:
        try:
            session = frida.attach(target_process)
            script = session.create_script(script_code)
            script.on('message', lambda message, data: print(CYAN + f"{message}" + RESET))
            script.load()
            print(CYAN + "Dynamic analysis in progress..." + RESET)
            time.sleep(5)
            session.detach()
        except Exception as e:
            print(RED + f"Error during dynamic analysis: {str(e)}" + RESET)

def main():
    print(CYAN + "Malware Reverse Engineering Tool" + RESET)
    print(BOLD + "=" * 30 + RESET)
    
    # User inputs
    file_path = input(YELLOW + "Enter the path to the malware sample: " + RESET).strip()
    
    # Optional inputs
    yara_rule_file = input(YELLOW + "Enter the path to the YARA rules file (or leave empty to skip): " + RESET).strip()
    target_process_name = input(YELLOW + "Enter the process name to analyze memory (or leave empty to skip): " + RESET).strip()
    target_process = input(YELLOW + "Enter the target process to attach for dynamic analysis (or leave empty to skip): " + RESET).strip()
    
    # File hash
    file_hash = calculate_hash(file_path)
    print(f"File SHA256 Hash: {CYAN}{file_hash}{RESET}")
    
    # PE Analysis
    analyze_pe(file_path)
    
    # Disassembly
    disassemble_binary(file_path)
    
    # YARA Rule Matching
    apply_yara_rules(file_path, yara_rule_file)
    
    # Memory Analysis
    analyze_process_memory(target_process_name)
    
    # Dynamic Analysis
    frida_script_code = """
        // Sample Frida code to intercept function calls
        Interceptor.attach(ptr("0x12345678"), {
            onEnter: function(args) {
                console.log('Function called with argument: ' + args[0]);
            }
        });
    """
    dynamic_analysis(frida_script_code, target_process)
    
    print(GREEN + "Analysis complete. Press Enter to exit..." + RESET)
    input()

if __name__ == "__main__":
    main()
