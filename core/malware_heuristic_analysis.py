import re
import pefile

# ANSI color codes for TUI
RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"

# Expanded heuristic rules for suspicious strings and patterns
SUSPICIOUS_STRINGS = [
    b'CreateRemoteThread',
    b'VirtualAllocEx',
    b'LoadLibrary',
    b'GetProcAddress',
    b'WriteProcessMemory',
    b'WinExec',
    b'CreateProcess',
    b'system32',
    b'powershell.exe',
    b'cmd.exe',
    b'Base64',
    b'RegOpenKey',
    b'GetModuleHandle',
    b'InternetOpen',
    b'GetUserName',
    b'ShellExecute',
    b'GetWindowsDirectory',
    b'WriteFile',
    b'StartProcess',
    b'HttpRequest',
    b'WScript'
]

SUSPICIOUS_PATTERNS = [
    (b'\x90\x90\x90', 10),  # NOP sled
    (b'\xcc\xcc\xcc', 5),   # INT3 breakpoints
    (b'\x6a\x00\x68', 7),   # Stack manipulation
    (b'\\x8B\\xEC', 10),    # Stack frame setup
    (b'\xB8\x00\x00\x00\x00', 5),  # MOV EAX, 0 (often used for nullification)
    (b'\xC7\x00\x00\x00\x00', 7)   # MOV [EAX], 0 (common in some types of exploits)
]

SUSPICIOUS_DLLS = [
    'kernel32.dll',
    'advapi32.dll',
    'user32.dll',
    'ws2_32.dll',
    'wininet.dll',
    'shell32.dll',
    'ntdll.dll',
    'msvcrt.dll'
]

class HeuristicMalwareChecker:
    def __init__(self):
        self.max_score = 100
        self.suspicious_score = 0
        self.suspicious_threshold = 50  # First-level flag threshold
        self.second_level_threshold = 75  # Second-level threshold for strong suspicion
        self.verbose_mode = True  # Enable verbose output

    def analyze_file(self, filepath):
        try:
            with open(filepath, 'rb') as file:
                content = file.read()
                self.verbose_print(CYAN + "Analyzing file:" + RESET, filepath)

                # Step 1: Check for suspicious strings
                self.check_suspicious_strings(content)

                # Step 2: Check for suspicious byte patterns
                self.check_suspicious_patterns(content)

                # Step 3: Check the imported modules (if it's a PE file)
                if filepath.lower().endswith(('.exe', '.dll')):
                    self.check_imported_modules(filepath)

                # Step 4: Perform second-level checks if the first-level score is high enough
                if self.suspicious_score >= self.suspicious_threshold:
                    self.perform_second_level_checks(filepath)

                return min(self.suspicious_score, self.max_score)

        except Exception as e:
            self.verbose_print(RED + f"Error analyzing file: {e}" + RESET)
            self.suspicious_score += 10  # Penalty for unexpected errors
            return min(self.suspicious_score, self.max_score)

    def check_suspicious_strings(self, content):
        found_count = 0
        for string in SUSPICIOUS_STRINGS:
            if string in content:
                self.suspicious_score += 5  # Adjusted value to fit the 100-point system
                found_count += 1
                self.verbose_print(YELLOW + f"Suspicious string found: {string.decode('utf-8')}" + RESET)

        # If multiple suspicious strings are found, increase score based on context
        if found_count >= 3:
            self.suspicious_score += 10
            self.verbose_print(YELLOW + "Multiple suspicious strings detected." + RESET)

    def check_suspicious_patterns(self, content):
        for pattern, score in SUSPICIOUS_PATTERNS:
            if re.search(pattern, content):
                self.suspicious_score += score
                self.verbose_print(YELLOW + f"Suspicious pattern found: {pattern}" + RESET)

    def check_imported_modules(self, filepath):
        try:
            pe = pefile.PE(filepath)
            imported_modules = [entry.dll.decode('utf-8').lower() for entry in pe.DIRECTORY_ENTRY_IMPORT]

            suspicious_count = 0
            for dll in imported_modules:
                if dll in SUSPICIOUS_DLLS:
                    self.suspicious_score += 10
                    suspicious_count += 1
                    self.verbose_print(YELLOW + f"Suspicious DLL imported: {dll}" + RESET)

            # If multiple suspicious DLLs are imported, increase the score
            if suspicious_count >= 2:
                self.suspicious_score += 15
                self.verbose_print(YELLOW + "Multiple suspicious DLLs detected." + RESET)

        except AttributeError:
            self.suspicious_score += 5  # Penalty for missing import directory
            self.verbose_print(RED + "Error: Missing import directory." + RESET)
        except pefile.PEFormatError:
            self.suspicious_score += 5  # Penalty for invalid PE format
            self.verbose_print(RED + "Error: Invalid PE format." + RESET)

    def perform_second_level_checks(self, filepath):
        try:
            pe = pefile.PE(filepath)

            # Check for unusual PE header anomalies
            if not pe.is_exe() or not pe.OPTIONAL_HEADER.AddressOfEntryPoint:
                self.suspicious_score += 15
                self.verbose_print(YELLOW + "Unusual PE header detected." + RESET)

            # Check for strange section names like `.upx` (commonly used by packers)
            for section in pe.sections:
                if b'UPX' in section.Name or b'.text1' in section.Name:
                    self.suspicious_score += 10
                    self.verbose_print(YELLOW + f"Suspicious section name: {section.Name.decode('utf-8')}" + RESET)

            # Check entropy (to detect packed or encrypted code)
            for section in pe.sections:
                entropy = section.get_entropy()
                if entropy > 7.5:  # High entropy indicates possible packed or encrypted section
                    self.suspicious_score += 10
                    self.verbose_print(YELLOW + f"High entropy detected in section: {section.Name.decode('utf-8')}" + RESET)

        except pefile.PEFormatError:
            self.suspicious_score += 5  # Penalty for invalid PE format
            self.verbose_print(RED + "Error: Invalid PE format." + RESET)

    def verbose_print(self, *messages):
        if self.verbose_mode:
            print(' '.join(str(msg) for msg in messages))

# Main function to run the checker
def main():
    file_path = input(YELLOW + "Enter the path of the file to analyze: " + RESET).strip()
    checker = HeuristicMalwareChecker()
    score = checker.analyze_file(file_path)
    print(GREEN + f"Suspicious Score: {score}/100" + RESET)

if __name__ == "__main__":
    main()
